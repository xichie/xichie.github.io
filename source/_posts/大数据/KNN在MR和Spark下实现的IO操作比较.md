---
title: KNN在MR和Spark下实现的IO操作比较
tags:
  - 大数据
toc: false
comments: true
mathjax: true
categories:
  - 大数据
abbrlink: 775bc24d
date: 2020-05-18 17:17:43
---
MapReduce中KNN运行过程I/O操作分析：

实现流程：

KNN在MapReduce中的实现，认为训练集大小远大于测试集大小。所以测试集缓存在内存中。

Map任务输入是一个训练集文件的分片（子集），测试集中的每一个样例与训练集分片中的所有样例计算距离，输出<测试样例， （与训练样例的距离和训练样例的类别）>

Combiner阶段根据map的输出得到距测试样例最近的K个训练样例，并输出。

Reduce任务：根据输入得到距测试样例最近的K个训练样例，并按投票原则得到对应的类别，输出到HDFS。



通过上述KNN在MapReduce中的流程分析产生的I/O操作的数量，分析I/O操作其实主要就是分析shuffle阶段的操作，具体分析如下：

1.首先Map端，map任务从HDFS中读取数据分片产生一次读操作。

2.当map函数处理完成每一条输入产生输出时，会将输出写入到一个默认大小为100M的缓冲区，当缓冲区的数据大小达到阈值（默认为缓冲区大小的80%），便会将缓冲区中的数据溢写到磁盘中，这个过程产生一次写操作。

3.上述过程会产生大量的溢写的小文件，map任务会将这些文件进行合并，在合并前会调用combiner函数，以减少写到磁盘的数据。这个过程产生一次读和写操作。

4.Reduce端的输入是若干map任务的map输出，所以在每个map任务完成时，就复制其输出到Reduce端本地磁盘。该过程会产生一次读和写操作。

5.最后在reduce阶段，直接把数据输入到reduce函数，产生一次读操作。Reduce函数对数据进行处理得到的输出直接写到HDFS中，产生一次写操作。

综上所述，KNN在mapreduce中的实现至少有4次读操作和4次写操作。

KNN在Spark中I/O操作分析：

由于Spark是基于内存的计算，所有的计算都在内存中进行。所以通常情况下，Spark任务都只有两次I/O操作，一次是读取数据形成RDD，一次是将计算的结果写入文件系统（HDFS）。

中间的操作都是在内存中进行的。但是如果有shuffle操作且内存不足以容纳所有的数据就可能会有I/O操作，在KNN的实现过程中，会有一次shuffle操作，所以可能会有一次读和写操作。综述，KNN在Spark中的实现至多会有两次读和两次写操作，最少会有一次读和一次写操作。